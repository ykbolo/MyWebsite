# 一条 js 函数作用域的题目及解析（题目和解析参考自牛客网）

## 关键词： **闭包** **引用**

### 时间：**2020.02.05**

#### 代码如下,求输出结果

```
function Foo() {
    var i = 0;
    return function() {
        console.log(i++);
    }
}

var f1 = Foo(),
    f2 = Foo();
f1();
f1();
f2();
```

可以看出这是一道比较绕人的题目,我最初的答案是 0 0 0，认为 i 作为函数内部的变量，每次执行到了 Foo()函数，他都会把 i 置为 0，但实际上不是这样的

一般来说函数执行完后它的局部变量就会随着函数调用结束被销毁，但是此题 foo 函数返回了一个匿名函数的引用（即一个闭包），它可以访问到 foo()被调用产生的环境，而局部变量 i 一直处在这个环境中，只要一个环境有可能被访问到，它就不会被销毁，所以说闭包有延续变量作用域的功能。这就好理解为什么

```
f1();// 0
f1();// 1
```

将目光集中到第一个 f1(),f1 是对于 Foo()对象的引用，因此执行`f1()`,相当于执行了 Foo()函数，打印出来的结果是 0

将目光集中到第二个 f1(),由于**闭包有延续变量**的作用，所以结果是 1

再看 f2(),由于 Foo()返回的是一个匿名函数，所以实际上 f1,f2 指向的是两个**不同的函数对象**，所以

```
f2();// 0
```

当然了，只有在极其特殊的情况下，才会写出这样的代码。这种题目能够比较好的让我们理解闭包和引用的特点,还是挺有意思的。
